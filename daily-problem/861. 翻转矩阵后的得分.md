#### [861. 翻转矩阵后的得分](https://leetcode-cn.com/problems/score-after-flipping-matrix/)

有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

返回尽可能高的分数。

```
示例：

输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
输出：39
解释：
转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39
```


提示：

`1 <= A.length <= 20`
`1 <= A[0].length <= 20`
`A[i][j] 是 0 或 1`

#### 解题思路

利用**贪心**算法，为了得到最高的分数，矩阵的每一行的最左边的数都必须为 1。为了做到这一点算法步骤如下

- 翻转那些最左边的数不为 1 的那些行，而其他的行则保持不动。

- 对于最左边的列而言，由于最优情况下，它们的取值都为 1，因此每个元素对分数的贡献都为 2<sup>n−1</sup>，总贡献为 m×2<sup>n−1</sup>。
- 对于第 j 列（j>0，此处规定最左边的列是第 0 列）而言，我们统计这一列0,1 的数量，令其中的最大值为 ones，则 ones 是列翻转后的 1的数量，该列的总贡献为k*2<sup>n−j−1</sup>。需要注意的是，在统计 0,1 的数量的时候，**要考虑最初进行的行反转**。

**代码演示：**

```go
func matrixScore(a [][]int) int {
    m, n := len(a), len(a[0])
    res := 1 << (n - 1) * m
    for j := 1; j < n; j++ {
        ones := 0
        for _, row := range a {
            //原则上是判断每列有多少个1，我们先把第一列全部置为1以后在判断其他列包含1的个数
            //（如第一列为0，第j个元素为0，翻转后都为1；第一列为1，第j个元素为1，不用翻转）,
            //所以只要row[j] == row[0]则该列第j个元素必为1
            if row[j] == row[0] {
                ones++
            }
        }
        //判断每列的1元素与0元素个数大小关系
        //如果1多则不用翻转，0多则要翻转
        if ones < m-ones {
            ones = m - ones
        }
        res += 1 << (n - 1 - j) * ones
    }
    return res
}
```

> - 时间复杂度：O(mn)，其中 m为矩阵行数，n为矩阵列数。
> - 空间复杂度：O(1)。