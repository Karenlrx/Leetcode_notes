#### [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1

 

```
示例 1：

输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
示例 2：

输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
示例 3：

输入：n = 0
输出：0


提示：

0 <= n <= 104


进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？
```



#### 解题思路

##### 方法一：暴力解

暴力法容易想到，但是会存在越界问题。要么采用bigInt要么做一些特殊处理：

- 因为如果出现了乘积尾数为0，0是不参与阶乘的运算的，所有val%10=0就可以val/=10

- 试验过后发现还是会越界，考虑如果当前数字过于大，因为n最多为10<sup>4</sup>，后续乘积不会直接影响高位数变为0，举例说明：

    ```
    30的阶乘为：
    26525 28598 12191 05863 63084 80000 000
    
    想要得到31的阶乘
    经过第一步处理后为：
    26525 28598 12191 05863 63084 8
    x							3 1
    ————————————————————————————————
    
    ```

    乘以一个2位数必不可能会让最终结果出现多于3个0，因此我们不需要关注高位的运算结果，只需要关注比如5863 63084 8即可。

    因此可以将原有的值保留不越界的较低位，如val%100000。







##### 方法二：数学法

- 实际上就是计算1-n之中有多少个5的因数。以130为例：

1. 第一次除以5时得到26，表明存在26个包含 [一] 个因数5的数；
2. 第二次除以5得到5，表明存在5个包含 [二] 个因数5的数(这些数字的一个因数5已经在第一次运算的时候统计了)；
3. 第三次除以5得到1，表明存在1个包含 [三] 个因数5的数(这些数字的两个因数5已经在前两次运算的时候统计了)；
4. 得到从1-n中所有5的因数的个数。

#### 代码演示

##### 方法一：暴力解

```go
func trailingZeroes(n int) int {
    val := 1
    res := 0
    for i:=1; i<=n; i++ {
        val = val*i
        for val%10 == 0 {
            val = val/10
            res++
        }
        val = val%1000000
    }

    return res
}
```

> - 时间复杂度：O(n)。
> - 空间复杂度：O(1)。



##### 方法二：数学法

```go
func trailingZeroes(n int) int {
    res :=  0  
    for n >= 5 {
        n = n/5
        res += n
    }
    return res
}
```

> - 时间复杂度：O(log n)。
> - 空间复杂度：O(1)。