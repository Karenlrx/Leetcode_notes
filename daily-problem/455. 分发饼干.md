#### [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```
示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
示例 2:

输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.


提示：

1 <= g.length <= 3 * 10^4
0 <= s.length <= 3 * 10^4
1 <= g[i], s[j] <= 2^31^ - 1
```

#### 解题思路（排序+贪心）

为了尽可能满足最多数量的孩子，从贪心的角度考虑，应该按照孩子的胃口从小到大的顺序依次满足每个孩子，且对于每个孩子，应该选择可以满足这个孩子的胃口且尺寸最小的饼干。证明如下。

假设有 m 个孩子，胃口值分别是 g<sub>1</sub>到 g<sub>m</sub>，有 n 块饼干，尺寸分别是 s<sub>1</sub>到 s<sub>n</sub>，满足 g<sub>i</sub> ≤g<sub>i+1</sub>和 s<sub>j</sub> ≤s<sub>j+1</sub>，其中 1≤i<m， 1≤j<n。

假设在对前 i−1 个孩子分配饼干之后，可以满足第 i 个孩子的胃口的最小的饼干是第 j 块饼干，即s<sub>j</sub> 是剩下的饼干中满足g<sub>i</sub>≤s<sub>j</sub>的最小值，最优解是将第 j 块饼干分配给第 i 个孩子。如果不这样分配，考虑如下两种情形：

- 如果 i<m 且 g<sub>i+1</sub>≤s<sub>j</sub> 成立，则如果将第 j 块饼干分配给第 i+1 个孩子，且还有剩余的饼干，则可以将第 j+1 块饼干分配给第 i 个孩子，分配的结果不会让更多的孩子被满足；

- 如果 j<n，则如果将第 j+1 块饼干分配给第 i 个孩子，当 g<sub>i+1</sub>≤s<sub>j</sub> 时，可以将第 j 块饼干分配给第 i+1 个孩子，分配的结果不会让更多的孩子被满足；当g<sub>i+1</sub>>s<sub>j</sub> 时，第 j 块饼干无法分配给任何孩子，因此剩下的可用的饼干少了一块，因此分配的结果不会让更多的孩子被满足，甚至可能因为少了一块可用的饼干而导致更少的孩子被满足。

基于上述分析，可以使用贪心算法尽可能满足最多数量的孩子。

**算法流程：**

- 对需求因子数组g与饼干大小数组s进行从小到大的排序。
- 按照从小到大的顺序使用各饼干尝试是否可满足某个孩子，每个饼干只尝试1次（因为如果该饼干不能满足最小胃口的孩子，那必定后面的都不能满足）。
- 若尝试成功，则将该饼干分配给这个孩子，i++，换下一个孩子尝试。
- 直到发现没更多的孩子或者没更多的饼干，循环结束。

**代码演示（Golang）**

```go
func findContentChildren(g []int, s []int) int {
	sort.Ints(g)
	sort.Ints(s)
	gLen, sLen := len(g), len(s)
	i,j := 0, 0
	for ; i < gLen && j < sLen; j++ {
		if s[j] >= g[i] {
			i++
		}
	}
	return i
}
```

> 时间复杂度：O(m log m+n log n)，其中 m 和 n 分别是数组 g 和 s 的长度。对两个数组排序的时间复杂度是 O(m log m+n log n)，遍历数组的时间复杂度是 O(m+n)，因此总时间复杂度是 O(m log m+n log n)。
>
> 空间复杂度：O(log m+log n)，其中 m 和 n 分别是数组 g 和 s 的长度。空间复杂度主要是排序的额外空间开销。
>