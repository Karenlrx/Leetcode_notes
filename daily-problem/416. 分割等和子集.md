#### [416. 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

```
注意:

每个数组中的元素不会超过 100
数组的大小不会超过 200
示例 1:

输入: [1, 5, 11, 5]

输出: true

解释: 数组可以分割成 [1, 5, 5] 和 [11].


示例 2:

输入: [1, 2, 3, 5]

输出: false

解释: 数组不能分割成两个元素和相等的子集.
```



**转换为 「0 - 1」 背包问题**
做这道题需要做一个等价转换：是否可以从输入数组中挑选出一些正整数，使得这些数的和等于整个数组元素的和的一半。容易知道：数组的和一定得是偶数。

本题与 0-1 背包问题有一个很大的不同，即：

0-1 背包问题选取的物品的容积总量 不能超过规定的总量；
本题选取的数字之和需要 恰好等于 规定的和的一半。
这一点区别，决定了在初始化的时候，所有的值应该初始化为 false。 

**「0 - 1」 背包问题的思路：**
作为「0-1 背包问题」，它的特点是：「每个数只能用一次」。解决的基本思路是：物品一个一个选，容量也一点一点增加去考虑，这一点是「动态规划」的思想，特别重要。
在实际生活中，我们也是这样做的，一个一个地尝试把候选物品放入「背包」，通过比较得出一个物品要不要拿走。

具体做法是：画一个 len 行，target + 1 列的表格。这里 len 是物品的个数，target 是背包的容量。len 行表示一个一个物品考虑，target + 1多出来的那 1 列，表示背包容量从 0 开始考虑。很多时候，我们需要考虑这个容量为 0 的数值。

状态与状态转移方程
状态定义：`dp[i][j]`表示从数组的 [0, i] 这个子区间内挑选一些正整数，每个数只能用一次，使得这些数的和恰好等于 j。
状态转移方程：很多时候，状态转移方程思考的角度是「分类讨论」，对于「0-1 背包问题」而言就是「当前考虑到的数字选与不选」。
不选择 `nums[i]`，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么` dp[i][j] = true`；
选择 `nums[i]`，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 `j - nums[i]`。
状态转移方程：

`dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]`
一般写出状态转移方程以后，就需要考虑初始化条件。

`j - nums[i] `作为数组的下标，一定得保证大于等于 0 ，因此 `nums[i] <= j`；
注意到一种非常特殊的情况：j 恰好等于 `nums[i]`，即单独 `nums[j] `这个数恰好等于此时「背包的容积」 j，这也是符合题意的。
因此完整的状态转移方程是：

![images-20201019170725367](images/images-20201019170725367.png)


说明：虽然写成花括号，但是它们的关系是 或者 。

初始化：`dp[0][0] = false`，因为候选数` nums[0]` 是正整数，凑不出和为 0；
输出：`dp[len - 1][target]`，这里 len 表示数组的长度，target 是数组的元素之和（必须是偶数）的一半。

**解释设置 `dp[0][0] = true` 的合理性（重点）**
修改状态数组初始化的定义：`dp[0][0] = true`。考虑容量为 0 的时候，即 `dp[i][0]`。按照本意来说，应该设置为 false ，但是注意到状态转移方程（代码中）：

`dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]`;
当 `j - nums[i] == 0` 成立的时候，根据上面分析，就说明单独的 `nums[i]` 这个数就恰好能够在被分割为单独的一组，其余的数分割成为另外一组。因此，我们把初始化的 dp[i][0] 设置成为 true 是没有问题的。

注意：观察状态转移方程，or 的结果只要为真，表格 这一列 下面所有的值都为真。因此在填表的时候，只要表格的最后一列是 true，代码就可以结束，直接返回 true。



**代码演示：**

```java
public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }

        // 剪枝：如果是奇数，就不符合要求
        if ((sum & 1) == 1) {
            return false;
        }

        int target = sum / 2;
        // 创建二维状态数组，行：物品索引，列：容量（包括 0）
        boolean[][] dp = new boolean[len][target + 1];

        // 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满
        if (nums[0] <= target) {
            dp[0][nums[0]] = true;
        }
        // 再填表格后面几行
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {
                // 直接从上一行先把结果抄下来，然后再修正
                dp[i][j] = dp[i - 1][j];

                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) {
                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];
                }
            }
        }
        return dp[len - 1][target];
    }
}
```



**空间优化：**

「0-1 背包问题」常规优化：「状态数组」从二维降到一维，减少空间复杂度。

在「填表格」的时候，当前行只参考了上一行的值，因此状态数组可以只设置 2 行，使用「滚动数组」的技巧「填表格」即可；

实际上，在「滚动数组」的基础上还可以优化，在「填表格」的时候，当前行总是参考了它上面一行 「头顶上」 那个位置和「左上角」某个位置的值。因此，我们可以只开一个一维数组，**从后向前逆序**依次填表即可。

「从后向前」 写的过程中，一旦 `nums[i] <= j `不满足，可以马上退出当前循环，因为后面的 j 的值肯定越来越小，没有必要继续做判断，直接进入外层循环的下一层。相当于也是一个剪枝，这一点是「从前向后」填表所不具备的。

**逆序原因：**

- 在一维情况下，是根据 `dp[j] || dp[j - nums[i]]`来推`d[j]的`值，如不逆序，就无法保证在外循环 i 值保持不变 j 值递增的情况下，`dp[j - num[i]]`的值不会被当前所放入的`nums[i]`所修改，当j值未到达临界条件前，会一直被`nums[i]`影响，也即是可能重复的放入了多次`nums[i]`，为了避免前面对后面产生影响，故用逆序。 
- 举个例子，数组为[2,2,3,5]，要找和为6的组合:
  - i = 0时，dp[2]为真，当i自增到1，j = 4时，`nums[i] = 2,dp[4] = dp[4] || dp[4 - 2]`为true
  - 当i不变，j = 6时,`dp[6] = dp [6] || dp [6 - 2]`,而`dp[4]`为true，所以`dp[6] = true`,显然是错误的。 故必须得纠正在正序情况下，i值不变时多次放入`nums[i]`的情况。

```java
public class Solution {

    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return false;
        }
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if ((sum & 1) == 1) {
            return false;
        }

        int target = sum / 2;
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;

        if (nums[0] <= target) {
            dp[nums[0]] = true;
        }
        for (int i = 1; i < len; i++) {
            for (int j = target; nums[i] <= j; j--) {
                if (dp[target]) {
                    return true;
                }
                dp[j] = dp[j] || dp[j - nums[i]];
            }
        }
        return dp[target];
    }
}

```

