#### 原题链接：

https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/

#### 题目描述：

写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

**答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。**

```
示例 ：
输入：n = 2
输出：1
```



**代码演示：**

```go
func fib(n int) int {
    if n ==0 || n == 1 {
        return n
    }
    a := 0 
    b := 1
    for i := 2 ; i <= n ; i++ {
         a , b = b , (a + b) % 1000000007
    }
    return b%1000000007
}
```

> 时间复杂度：O(n)   空间复杂度：O(1)
>
> 执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户
>
> 内存消耗 :1.9 MB, 在所有 Go 提交中击败了100.00%的用户



```go
func fib (n int) int {
    if n==0 ||n==1{
        return n
    }
    res := make([]int , n+1)
    res[0] = 0
    res[1] = 1
    for i := 2 ; i <= n ; i++ {
        res[i] =( res [i-1] + res [i-2]) % 1000000007
    }
    return res[n]
}
```

> 时间复杂度：O(n)   空间复杂度：O(n)
>
> 执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户
>
> 内存消耗 :2.0 MB, 在所有 Go 提交中击败了100.00%的用户



Golang的闭包使用：一般来说，函数内部是不能嵌套函数的，但可以使用闭包的形式，在闭包中

**闭包 = 匿名函数 + 外层变量引用**

闭包作用非常大的。 比如我们要对一个函数进行扩展的时候。
我们需要符合封闭开放原则。 也就是我们不能对源代码进行修改, 但是还要进行扩展。
这时候就可以引入闭包。对于闭包的解释比较好的文章如下链接所示：

> https://zhuanlan.zhihu.com/p/92634505

```go
func fib(n int) int {
    if n == 0 || n == 1{
    return n
    }
    b0 := 0
    b1 := 1
    f := func(){
    tmp := (b0 + b1) % 1000000007
    b0 = b1
    b1 = tmp
    }
    for i := 1; i < n; i++{
    f()
    }
    return b1
}

```

> 时间复杂度：O(n)   **空间复杂度：O(1)？？**
>
> 执行用时 :0 ms, 在所有 Go 提交中击败了100.00%的用户
>
> 内存消耗 :1.9 MB, 在所有 Go 提交中击败了100.00%的用户